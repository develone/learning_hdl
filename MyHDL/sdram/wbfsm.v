// File: wbfsm.v
// Generated by MyHDL 0.10
// Date: Tue Oct  2 15:24:38 2018


`timescale 1ns/10ps

module wbfsm (
    clk_i,
    reset_i,
    i_wb_cyc,
    i_wb_stb,
    i_wb_we,
    i_wb_addr,
    i_wb_data,
    o_wb_ack,
    o_wb_stall,
    o_wb_data,
    i_wb_sel,
    sd_intf_cke,
    sd_intf_we,
    sd_intf_addr,
    sd_intf_dqml,
    sd_intf_cas,
    sd_intf_dqmh,
    sd_intf_ras,
    sd_intf_bs,
    sd_intf_cs,
    sd_intf_dq,
    host_intf_wr_i,
    host_intf_done_o,
    host_intf_rdPending_o,
    host_intf_rst_i,
    host_intf_data_i,
    host_intf_data_o,
    host_intf_rd_i,
    host_intf_addr_i
);


input clk_i;
input reset_i;
input i_wb_cyc;
input i_wb_stb;
input i_wb_we;
input [31:0] i_wb_addr;
input [15:0] i_wb_data;
output o_wb_ack;
reg o_wb_ack;
output o_wb_stall;
reg o_wb_stall;
output [15:0] o_wb_data;
wire [15:0] o_wb_data;
input [3:0] i_wb_sel;
output sd_intf_cke;
reg sd_intf_cke;
output sd_intf_we;
reg sd_intf_we;
output [12:0] sd_intf_addr;
reg [12:0] sd_intf_addr;
output sd_intf_dqml;
reg sd_intf_dqml;
output sd_intf_cas;
reg sd_intf_cas;
output sd_intf_dqmh;
reg sd_intf_dqmh;
output sd_intf_ras;
reg sd_intf_ras;
output [1:0] sd_intf_bs;
reg [1:0] sd_intf_bs;
output sd_intf_cs;
reg sd_intf_cs;
inout [15:0] sd_intf_dq;
wire [15:0] sd_intf_dq;
output host_intf_wr_i;
wire host_intf_wr_i;
input host_intf_done_o;
input host_intf_rdPending_o;
output host_intf_rst_i;
wire host_intf_rst_i;
output [15:0] host_intf_data_i;
wire [15:0] host_intf_data_i;
input [15:0] host_intf_data_o;
output host_intf_rd_i;
wire host_intf_rd_i;
output [23:0] host_intf_addr_i;
wire [23:0] host_intf_addr_i;

reg rand_load;
reg rand_enable;
reg rd_enable;
wire [15:0] rand_val;
reg [1:0] test_state;
reg [26:0] address;
reg wr_enable;
reg error;
reg [15:0] data_delay0_0_1_2_tmpdata1;
reg [15:0] data_delay0_0_1_2_tmpdata;


// In this section data is transferred to host_intf

assign host_intf_rst_i = reset_i;
assign host_intf_wr_i = (wr_enable && (!host_intf_done_o));
assign host_intf_rd_i = (rd_enable && (!host_intf_done_o));
assign host_intf_data_i = rand_val;
assign host_intf_addr_i = address;
assign o_wb_data = host_intf_data_o;


always @(posedge clk_i) begin: WBFSM_SDRAM_FSM
    if ((reset_i == 1'b1)) begin
        error <= 1'b0;
        test_state <= 2'b01;
    end
    else if ((test_state == 2'b01)) begin
        rand_load <= 1;
        // Load the data_i into tmpdata
        // this is the write & read req using wb
        // i_wb_stb & i_wb_we is 1 is a write
        // i_wb_stb & i_wb_we is 0 is a read
        if (((i_wb_cyc == 1) && (i_wb_sel == 15))) begin
            o_wb_stall <= 1;
            o_wb_ack <= 0;
            // this is the write req from wb
            // i_wb_we is 1
            if ((i_wb_we == 1)) begin
                rand_load <= 0;
                address <= i_wb_addr;
                rand_enable <= 1;
                // copy the the tmpdata which 
                // is the data_i to tmpdata1
            end
            else begin
                // this is the read req from wb
                address <= i_wb_addr;
                // wait for read to be done
                if ((host_intf_done_o == 0)) begin
                    rd_enable <= 1;
                end
                else begin
                    o_wb_stall <= 0;
                    o_wb_ack <= 1;
                    rd_enable <= 0;
                    test_state <= 2'b10;
                end
            end
            // wait for write to be done
            if ((host_intf_done_o == 0)) begin
                wr_enable <= 1;
                o_wb_stall <= 1;
            end
            else begin
                o_wb_stall <= 0;
                o_wb_ack <= 1;
                wr_enable <= 0;
                rd_enable <= 0;
                rand_enable <= 0;
                rand_load <= 1;
                test_state <= 2'b10;
            end
        end
    end
    else begin
        rand_load <= 1;
        rand_enable <= 0;
        o_wb_ack <= 0;
        error <= 1'b0;
        if ((i_wb_stb == 1)) begin
            test_state <= 2'b01;
        end
    end
end



assign rand_val = data_delay0_0_1_2_tmpdata1;


always @(posedge clk_i) begin: WBFSM_DATA_DELAY0_0_1_2_DELAYED
    if (rand_load) begin
        data_delay0_0_1_2_tmpdata <= i_wb_data;
    end
    else if (rand_enable) begin
        data_delay0_0_1_2_tmpdata1 <= data_delay0_0_1_2_tmpdata;
    end
end

endmodule
